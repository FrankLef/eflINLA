
#' Predictions using an `inla` model object
#'
#' Predictions using an `inla` model object with new data.
#'
#' Make predictions using the `INLA::inla.posterior.sample` function, then
#' extract the linear predictors and add variability to them.
#'
#' @source Bayesian Inference with INLA, Virgilio Gomez-Rubio, 2020, section 2.7,
#' p. 35-38
#'
#' @param object Object of class `inla` with the new data.
#' @param pos Integer() with the position of the row with dependent variable
#' set to `NA` in the new data.
#' @param n sample size.
#'
#' @return Dataframe with simulated predictions.
#' @export
predict_inla <- function(object, pos, n = 1L) {

  # .Defunct(new = "posterior_samples")

  checkmate::assert_class(object, classes = "inla")
  checkmate::assert_integerish(pos, lower = 1L, min.len = 1L, unique = TRUE)
  checkmate::assert_count(n, positive = TRUE)

  # get the samples
  samples <- INLA::inla.posterior.sample(n = n, result = object)

  # extract data from samples which will be simulated
  sim_data <- predict_inla_extract(samples, pos)

  # add variability to predictors using the sigmas
  predict_inla_sim(sim_data)
}


#' Extract the data from `inla` posterior samples
#'
#' Extract the data from `inla` posterior samples to simulate.
#'
#' Extract the data necessary to add variability to the linear predictors
#' by simulation.  This is the function that does most of the essential work
#' in the predict process.
#'
#' @param samples List of samples returned by `inla.posterior.sample`
#' @inheritParams predict_inla
#'
#' @return List with 2 lists: the predictors and the sigmas.
predict_inla_extract <- function(samples, pos) {

  # the position of the precision hyperparameter in every sample
  prec_pos <- grep(pattern = "^Precision", names(samples[[1]]$hyperpar))
  # get the sigma from every sample
  sigmas <- sapply(X = samples,
                   FUN = function(x) {
                     1 / sqrt(x$hyperpar[[prec_pos]])
                   })
  sigmas <- sapply(X = samples,
                   FUN = function(x) {
                     prec2sd(x$hyperpar[[prec_pos]])
                   })
  assertthat::not_empty(sigmas)

  # get the predictors from every sample
  predictors <- lapply(X = samples, FUN = function(x) x$latent[pos, ])
  assertthat::not_empty(predictors)

  # sigmas and predictors must be list of equal length
  assertthat::are_equal(length(sigmas), length(predictors))
  # output as a list
  list(sigmas = sigmas, predictors = predictors)
}



#' Simulate the predictions from `inla`
#'
#' Simulate the predictions from `inla`.
#'
#' Add variability to the predictors by by simulation.
#'
#' @param sim_data List with predictors and sigmas. Generated by
#' `predict_inla_extract`.
#'
#' @return Dataframe of simulations.
#'
#' @importFrom stats setNames rnorm
#' @importFrom dplyr %>%
predict_inla_sim <- function(sim_data) {
  checkmate::assert_list(sim_data, len = 2L)

  # the names of the predictors, taken from the first sample
  the_names <- names(sim_data$predictors[[1]])

  # add the variability to the predictors
  out <- mapply(FUN = function(mu, sigma) {
    rnorm(n = length(mu), mean = mu, sd = sigma)
    },
    sim_data$predictors,
    sim_data$sigmas) %>%
    t() %>%
    as.data.frame() %>%
    setNames(nm = the_names)
  assertthat::are_equal(dim(out), c(length(sim_data$predictors), length(the_names)))
  out
}
